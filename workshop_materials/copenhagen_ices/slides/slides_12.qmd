---
title: "Lecture 12"
from: markdown+emoji
subtitle:  "Dealing with many zeros" 
format:
  revealjs:
    margin: 0
    logo:  NTNU_UofG.png
    theme: uofg_theme.scss
    header-includes: |
      <script src="custom.js" type="application/javascript"></script>
slide-number: "c/t"
title-slide-attributes:
#    data-background-image: images/trondheim3.png
    data-background-size: cover
    data-background-opacity: "0.55"
author:
  - name: Sara Martino
    #orcid: 0000-0002-6879-4412
    email: sara.martino@ntnu.no
    affiliations: Dept. of Mathematical Science, NTNU
  - name: Janine Illian
    #orcid: 0000-0002-6879-4412
    email: Janine.Illian@glasgow.ac.uk
    affiliations: University of Glasgow 
  - name: Jafet Belmont
    #orcid: 0000-0002-6879-4412
    email: Jafet.Belmont@glasgow.ac.uk
    affiliations: University of Glasgow   
        
# date: May 22, 2025
# bibliography: references.bib
embed-resources: true
execute:
  allow-html: true
  freeze: auto
---

```{r setup}
# #| include: false

knitr::opts_chunk$set(echo = FALSE,
                      message=FALSE,
                      warning=FALSE,
                      strip.white=TRUE,
                      prompt=FALSE,
                      fig.align="center",
                       out.width = "60%")

library(knitr)    # For knitting document and include_graphics function
library(ggplot2)  # For plotting
library(png)
library(tidyverse)
library(INLA)
library(BAS)
library(patchwork)
library(DAAG)
library(inlabru)
library(cowplot) # needs install.packages("magick") to draw images

```

## Motivation

::: incremental
-   Count data are often modeled with **Poisson** or **Negative Binomial** models.\

-   These assume zeros occur naturally from the count process.

    -   Example: for Poisson is $P(Y=0) = \exp(\lambda)$

-   But in real data, we often see **too many zeros** → *zero inflation*.

-   Examples:

    -   Many people have **0 doctor visits** per year.\
    -   Most customers have **0 claims**.\
    -   Many species are **absent** from samples.
:::

## Two main solutions

Both handle excess zeros but use **different assumptions** about how zeros are generated.

-   **Zero-Inflated** Models

-   **Hurdle** Models

## Two main solutions

Both handle excess zeros but use **different assumptions** about how zeros are generated.

-   **Zero-Inflated** Models

    -   Two sources of zero: inflation process or count process

-   **Hurdle** Models

## Two main solutions

Both handle excess zeros but use **different assumptions** about how zeros are generated:

-   **Zero-Inflated** Models

    -   Two sources of zero: inflation process or count process

-   **Hurdle** Models

    -   Onle one source of zeros

## Zero-Inflated Models

Assume two processes:

-   A binary process → decides if the observation is a certain zero.

-   A count process → generates counts, *including* zeros.

$$
\begin{aligned}
\text{P}(Y=0) & = \pi + (1-\pi)f(0) & \\
\text{P}(Y=y) & = (1-\pi)f(y)& y=1,2,\dots
\end{aligned}
$$

. . .

**Note** In zero-inflated models $f(y)$ is typically discrete (ex Poisson, Binomial, ...)

## Hurdle Models {.smaller}

Also have two parts, but different logic:

-   A binary model determines if the observation crosses the hurdle (i.e. zero vs. positive).

-   A **truncated** count model models only positive counts.

**Zeros come only from the first process**.

$$
\begin{aligned}
\text{P}(Y=0) & = \pi & \\
\text{P}(Y=y) & = \frac{f(y)}{1-f(0)}& y=1,2,\dots
\end{aligned}
$$

. . .

**Note** In hurdle models $f_Y(y)$ can also be continuous (f.ex Gamma). In these cases: $$
\begin{aligned}
\text{P}(Y=0) & = \pi & \\
f_Y(y) & = f(y)& y>0
\end{aligned}
$$ where $f(y)$ is scaled so that it integrates to $1-\pi$

## Comparison: Zero-Inflated vs. Hurdle Models

| Feature | Zero-Inflated | Hurdle |
|:---|:---|:---|
| **Zeros come from** | Two sources (inflation + count) | One source (hurdle only) |
| **Positive part** | Includes zeros | Truncated at zero |
| **Can use continuous distributions?** | :x: Typically count only | :white_check_mark: Yes (Gamma, Lognormal) |

## Zero Inflated models in `inlabru` (Type 1)

-   Four zero-inflated models are implemented
    -   Poisson (`zeroinflatedpoisson1`)
    -   Binomial (`zeroinflatedbinomial1`)
    -   Negative Binomial (`zeroinflatednbinomial1`)
    -   BetaBinomial (`zeroinflatedbinomial1`)

To get details about the distributions you can type

```{r}
#| echo: true
#| eval: false

INLA::inla.doc("zero inflated")

```

. . .

The probability of the inflation process $\pi$ is a *hyperparameter* therefore cannot be modeled with covariates

## Example: number of fishes caught by fishermen at a state park.

```{r}
#| echo: false
zinb <- read.csv("https://stats.idre.ucla.edu/stat/data/fish.csv") %>%
  filter(count<40) %>%
  dplyr::select(-c(livebait, camper, xb,zg))

#Example 2. The state wildlife biologists want to model how many fish are being caught by fishermen at a state park. Visitors are asked how long they stayed, how many people were in the group, were there children in the group and how many fish were caught. Some visitors do not fish, but there is no data on whether a person fished or not. Some visitors who did fish did not catch any fish so there are excess zeros in the data because of the people that did not fish.
```

```{r}
#| echo: false
zinb[1:3,]
ggplot() + geom_histogram(data= zinb, aes(x = count, y = ..density..), binwidth = 1)


```

## Example: two models

$$
\begin{eqnarray}
\text{Model 1:   }\ & Y\sim \text{Poisson}(\lambda)\\
\text{Model 2:   }\ & Y\sim \text{NegBinomial}(n,p)\\
\text{Linear predictor:   }\ & \eta = \beta_0 + \beta_1x_1 + \beta_2x_2
\end{eqnarray}
$$

## Example: two models {.smaller}

$$
\begin{eqnarray}
\text{Model 1:   }\ & Y\sim \text{Poisson}(\lambda)\\
\text{Model 2:   }\ & Y\sim \text{NegBinomial}(n,p)\\
\text{Linear predictor:   }\ & \eta = \beta_0 + \beta_1x_1 + \beta_2x_2
\end{eqnarray}
$$

**Negative Binomial distribution**

```{r}
#| eval: false

inla.doc("negative binomial")
```

$$
\text{Prob}(Y=y) = \frac{\Gamma(y+n)}{\Gamma(n)\Gamma(y+1)}p^n(1-p)^y
$$ with $$
E(Y) = \mu = n\frac{1-p}{p} \qquad \text{Var}(Y) = \mu(1+\frac{\mu}{n})
$$ and linear predictor $\eta = log(\mu)$

## Example: Implementation {.smaller auto-animate="true"}

::::: columns
::: {.column width="65%"}
**The Model** $$
\begin{aligned}
\text{Model 1 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{Pois}(\lambda(\eta_i))\\
\text{Model 2 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{NegBin}(n(\eta_i),p(\eta_i))\\
\text{Linear Predictor }: \eta_i & = \color{red}{\boxed{\beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i}}}
\end{aligned}
$$
:::

::: {.column width="35%"}
```{r}
#| echo: true
zinb[1:3,]
```
:::
:::::

**The code**

```{r}
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| code-line-numbers: "1-7"

# define model components
cmp = ~ Intercept(1) + fishing(nofish, model = "linear") + 
  persons(persons, model = "linear") + 
  child(child, model = "linear")

# define model predictor
formula = count ~ .

# build the observation model
# Poisson model
lik_pois = bru_obs(formula,
                   family = "zeroinflatedpoisson1",
                   data = zinb) 

# Negative binomial model
lik_nbin = bru_obs(formula,
                   family = "zeroinflatednbinomial1",
                   data = zinb) 

# fit the model
fit_pois = bru(cmp, lik_pois)
fit_nbin = bru(cmp, lik_nbin)

```

## Example: Implementation {.smaller auto-animate="true"}

::::: columns
::: {.column width="65%"}
**The Model** $$
\begin{aligned}
\text{Model 1 }:  \color{red}{\boxed{y_i|\eta_i}} & \color{red}{\boxed{\sim \pi1_{(y=0)} + (1-\pi)\text{Pois}(\lambda(\eta_i))}}\\
\text{Model 2 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{NegBin}(n(\eta_i),p(\eta_i))\\
\text{Linear Predictor }: \eta_i & = \beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i}
\end{aligned}
$$
:::

::: {.column width="35%"}
```{r}
#| echo: true
zinb[1:3,]
```
:::
:::::

**The code**

```{r}
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| code-line-numbers: "9-13,21"

# define model components
cmp = ~ Intercept(1) + fishing(nofish, model = "linear") + 
  persons(persons, model = "linear") + 
  child(child, model = "linear")

# define model predictor
formula = count ~ .

# build the observation model
# Poisson model
lik_pois = bru_obs(formula,
                   family = "zeroinflatedpoisson1",
                   data = zinb) 

# Negative binomial model
lik_nbin = bru_obs(formula,
                   family = "zeroinflatednbinomial1",
                   data = zinb) 

# fit the model
fit_pois = bru(cmp, lik_pois)
fit_nbin = bru(cmp, lik_nbin)

```

## Example: Implementation {.smaller auto-animate="true"}

::::: columns
::: {.column width="65%"}
**The Model** $$
\begin{aligned}
\text{Model 1 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{Pois}(\lambda(\eta_i))\\
\text{Model 2 }:  \color{red}{\boxed{y_i|\eta_i}} & \color{red}{\boxed{\sim \pi1_{(y=0)} + (1-\pi)\text{NegBin}(n(\eta_i),p(\eta_i))}}\\
\text{Linear Predictor }: \eta_i & = \beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i}
\end{aligned}
$$
:::

::: {.column width="35%"}
```{r}
#| echo: true
zinb[1:3,]
```
:::
:::::

**The code**

```{r}
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| code-line-numbers: "15-18,22"

bru_options_set(control.compute = list(dic = T, waic = T, mlik = T))
# define model components
cmp = ~ Intercept(1) + fishing(nofish, model = "linear") + 
  persons(persons, model = "linear") + 
  child(child, model = "linear")

# define model predictor
formula = count ~ .

# build the observation model
# Poisson model
lik_pois = bru_obs(formula,
                   family = "zeroinflatedpoisson1",
                   data = zinb) 

# Negative binomial model
lik_nbin = bru_obs(formula,
                   family = "zeroinflatednbinomial1",
                   data = zinb) 

# fit the model
fit_pois = bru(cmp, lik_pois)
fit_nbin = bru(cmp, lik_nbin)

```

## Results - Fixed effects

```{r}
print("Poisson Model")
round(fit_pois$summary.fixed[,c(1,2,3,5)],2)
print("Negative Binomial Model")
round(fit_nbin$summary.fixed[,c(1,2,3,5)],2)

```

## Results - Hyperparameters and scores

Hyperparameters

```{r}
print("Poisson Model")
round(fit_pois$summary.hyperpar[,c(1,2)],2)
print("Negative Binomial Model")
round(fit_nbin$summary.hyperpar[,c(1,2)],2)

```

Scores

```{r}
#| eval: true
dd = data.frame( 
  Score = c("DIC", "Mlik", "WAIC"),
  Poisson = round(c(fit_pois$dic$dic, fit_pois$mlik[1], fit_pois$waic$waic),2),
  Nbin = round(c(fit_nbin$dic$dic, fit_nbin$mlik[1], fit_nbin$waic$waic),2))

dd
```

::: notes
There seems to be more overdispersion than excess zero..the negative binomial model better fits the data estimateing a small excess of zero.
:::

## Comparing estimated distribution for a specific data point

$$
\begin{eqnarray}
\text{Model 1:   }\ & P(Y=0) &= \pi + (1-\pi)\ \text{Poisson}(\lambda)\\
\text{Model 2:   }\ & P(Y=0)&= \pi + (1-\pi)\ \text{NegBinom}(n,p)\\
\end{eqnarray}
$$ We check the distribution for one person, non-fisher and no children

```{r}
#| eval: true
#| echo: false
df_pred = data.frame(nofish = 0, persons = 1, child = 0)

prob_pois = predict(fit_pois, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_poisson_1
          lambda = exp(Intercept +  fishing + persons + child)
          yy = 0:20
          list(
            prob0 =  pi0 * c(1,rep(0,20)) + (1-pi0) * dpois(yy, lambda = lambda))
          } )


prob_nbin = predict(fit_nbin, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_nbinomial_1
          size = exp(size_for_nbinomial_1_zero_inflated_observations)
          mu = exp(Intercept +  fishing + persons + child)
          p = size/(size + mu)
          yy = 0:20
          list(prob0 = pi0 * c(1,rep(0,20)) + (1-pi0) * dnbinom(yy,size = size, mu = mu))
        })

rbind(prob_pois$prob0 %>% mutate(y = 0:20, model= "Poisson"),
      prob_nbin$prob0 %>% mutate(y = 0:20, model= "NegBin")) %>%
  ggplot() + geom_point(aes(y, mean)) +
  geom_errorbar(aes(y, ymin = q0.025, ymax = q0.975)) +
  facet_wrap(.~model) + ylab("Probability")

```

## Comparing estimated distribution - Implementation

```{r}
#| eval: false
#| echo: true
df_pred = data.frame(nofish = 0, persons = 1, child = 0)

prob_pois = predict(fit_pois, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_poisson_1
          lambda = exp(Intercept +  fishing + persons + child)
          yy = 0:20
          list(
            prob0 =  pi0 * c(1,rep(0,20)) + (1-pi0) * dpois(yy, lambda = lambda))
          } )

prob_nbin = predict(fit_nbin, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_nbinomial_1
          size = exp(size_for_nbinomial_1_zero_inflated_observations)
          mu = exp(Intercept +  fishing + persons + child)
          p = size/(size + mu)
          yy = 0:20
          list(prob0 = pi0 * c(1,rep(0,20)) + (1-pi0) * dnbinom(yy,size = size, mu = mu))
        })
```

## Comparing estimated distribution - Implementation

Note: To get the names to input in `predict` use the `bru_standardise_names()` function:

```{r}
#| echo: true
#| eval: false

inlabru::bru_standardise_names(fit_pois)

```

## Hurdle Models in `inlabru`

There are two ways to implement hurdle models in `inlabru`

-   **Strategy 1** Use a modified version of the same distributions defined for the zero-inflated models

-   **Strategy 2** Use a "two-likelihood" trick

## Strategy 1 - Implemented models {.smaller}

**Available models** (Type 0)

-   Poisson (`zeroinflatedpoisson0`)

-   Binomial (`zeroinflatedbinomial0`)

-   Negative Binomial (`zeroinflatednbinomial0`)

-   BetaBinomial (`zeroinflatedbinomial0`)

. . .

**Advantages**

-   It works exactly as the zero-inflated models
-   No need for extra coding

. . .

**Disadvantages**

-   Can only be used for the models that are already implemented
-   The probability of zero ($\pi$) is fixed and cannot have covariates

## Example Strategy 1: Implementation {.smaller auto-animate="true"}

::::: columns
::: {.column width="65%"}
**The Model** $$
\begin{aligned}
\text{Model 1 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{TruncPois}(\lambda(\eta_i))\\
\text{Model 2 }:  y_i|\eta_i & \sim \pi1_{(y=0)} + (1-\pi)\text{TruncNegBin}(n(\eta_i),p(\eta_i))\\
\text{Linear Predictor }: \eta_i & = \beta_0 + \beta_1 x_{1i} + \beta_2 x_{2i}
\end{aligned}
$$
:::

::: {.column width="35%"}
```{r}
#| echo: true
zinb[1:3,]
```
:::
:::::

**The code**

```{r}
#| echo: true
#| eval: true
#| warning: false
#| message: false

# define model components
cmp = ~ Intercept(1) + fishing(nofish, model = "linear") + 
  persons(persons, model = "linear") + 
  child(child, model = "linear")

# define model predictor
formula = count ~ .

# build the observation model
# Poisson model
lik_pois = bru_obs(formula,
                   family = "zeroinflatedpoisson0",
                   data = zinb) 

# Negative binomial model
lik_nbin = bru_obs(formula,
                   family = "zeroinflatednbinomial0",
                   data = zinb) 

# fit the model
fit_pois0 = bru(cmp, lik_pois)
fit_nbin0 = bru(cmp, lik_nbin)

```

## Example Strategy 1: Results

```{r}
prob_pois0 = predict(fit_pois0, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_poisson_0
          lambda = exp(Intercept +  fishing + persons + child)
          yy = 0:20
          list(
            prob0 =  pi0 * c(1,rep(0,20)) + (1-pi0) * dpois(yy, lambda = lambda))
          } )


prob_nbin0 = predict(fit_nbin0, df_pred,
        formula = ~ {
          pi0 <- zero_probability_parameter_for_zero_inflated_nbinomial_0
          size = exp(size_for_nbinomial_0_zero_inflated_observations)
          mu = exp(Intercept +  fishing + persons + child)
          p = size/(size + mu)
          yy = 0:20
          list(prob0 = pi0 * c(1,rep(0,20)) + (1-pi0) * dnbinom(yy,size = size, mu = mu))
        })

rbind(prob_pois$prob %>% mutate(y = 0:20, model= "Poisson", type = "zero-inflated (Type 1)"),
      prob_nbin$prob %>% mutate(y = 0:20, model= "NegBin", type = "zero-inflated (Type 1)"),
      prob_pois0$prob %>% mutate(y = 0:20, model= "Poisson", type = "hurdle (Type 0)"),
      prob_nbin0$prob %>% mutate(y = 0:20, model= "NegBin", type = "hurdle (Type 0)")

      ) %>%
  ggplot() + geom_point(aes(y, mean, color = type)) +
  geom_errorbar(aes(y, ymin = q0.025, ymax = q0.975, color = type)) +
  facet_wrap(.~model) + ylab("Probability")
```

## Strategy 2 - Two-likelihood trick

**Advantages**

-   More flexible model
-   Can model also the probability of zero $\pi$
-   Can also be used for continuous distributions with mass at 0

. . .

**Disadvantage**

-   Some more coding

## Hurdle models com

The Hurdle Model handles this by splitting the data-generating process into two parts:

1.  **Zero-hurdle component**: This part is a binary model that estimates the probability of a zero count versus a non-zero count.
2.  **Positive component**: This part models the distribution of the positive (non-zero) values.

. . .

This idea can be used in `inlabru` by using two likelihood

-   A binomial likelihood to model the 0/1 process
-   A continuous **positive** density or a **truncated** count distribution for the positive part

## Example - Gamma-Hurdle model {.smaller}

Daily precipitation in Parana state

::::: columns
::: {.column width="50%"}
$$
z_{st} = \left\{
\begin{eqnarray}
0 & \text{ if } &\text{ no rain on day } t \text{ at station } s\\
1 & \text{ if } &\text{  rain on day } t \text{ at station } s
\end{eqnarray}
\right.
$$

$$
y_{st} = \left\{
\begin{eqnarray}
\text{NA} \text{ if } && \text{ no rain on day } t  \text{ at station } s\\
\text{rain amout} \text{ if } && \text{  rain on day } t  \text{ at station } s
\end{eqnarray}
\right.
$$
:::

::: {.column width="50%"}
```{r}
library(sf)
data(PRprec)
df  = st_as_sf(PRprec, coords = c("Longitude", "Latitude"),
         crs = st_crs("+proj=longlat +datum=WGS84")) %>%
  mutate(station = seq_along(geometry))

df = df %>% pivot_longer(-c(geometry, Altitude, station)) %>%
  mutate(time = as.numeric(as.factor(name)))

# Time series of the daily rain amount, with smoother curve

p1 = ggplot(df %>% filter(station==1),aes(time, value)) +
  geom_segment(aes(x = time, xend = time, y = 0, yend = value)) +
  xlab("Date") +
  ylab("Rain (mm)") +
  ggtitle("Daily rain amount")




# Histogram of the daily rain amount

p2  = ggplot(df %>% filter(station ==1 ),aes(value)) +
  geom_histogram(binwidth = 1,colour = "blue", fill = "darkgrey") +
 # scale_x_continuous(breaks = seq(0,80,5)) +
#  scale_y_continuous(breaks = seq(0,225,25)) +
  xlab("Rain (mm)") +
  ylab ("Frequency (days)") +
  ggtitle("Daily rain amount distribution")
p1 + p2





ggplot() + geom_sf(data = df, aes(color = Altitude))


xys = st_as_sf(data.frame(PRborder), coords = c("Longitude", "Latitude"), crs = st_crs("+proj=longlat +datum=WGS84"))

points_list <- list(PRborder)
poly <- st_sfc(st_polygon(points_list), crs = st_crs("+proj=longlat +datum=WGS84"))

mesh = mesh = fm_mesh_2d(loc = df, crs = st_crs(df), max.edge = c(30,50),
                         cutoff = 0.1)
spde = inla.spde2.pcmatern(
  mesh, prior.range = c(100, 0.5), prior.sigma = c(0.5, 0.5))
```
:::
:::::

$$
z_{st}\sim \text{Binom}(p_{st}, n_{st} = 1); \qquad y_{st}|z_{st}=1\sim\text{Gamma}(a,b) \ \text{with}\  E(y_{st}) = \mu_{st} =  a/b
$$ Where $$
\begin{eqnarray}
\eta_t^1 & = \text{logit}(p_t)  & = \beta_0^B+u^B(s) \\
\eta_t^2 & = \log(\mu_t)& = \beta_0^G+u^G(s)
\end{eqnarray}
$$

## Example - Gamma-Hurdle model

**Implementation**

1.  Create response for binary and Gamma process

```{r}
#| echo: true
df = df %>%
  mutate(z = ifelse(value==0,0,1),
         y = ifelse(value==0,NA, value),)
```

2.  Define components, observation models and run

```{r}
#| echo: true
#| cache: true
cmp = ~ -1 + Intercept_z(1) + Intercept_y(1) +
  space_z(geometry, model = spde) +
  space_y(geometry, model = spde) +
  local_z(station, model = "iid")

lik_z = bru_obs(formula = z ~ Intercept_z + space_z + local_z,
                data = df %>% filter(time==1),
                family = "binomial")

lik_y = bru_obs(formula = y ~ Intercept_y + space_y,
                data =  df %>% filter(time==1),
                family = "gamma")

fit = bru(cmp, lik_z, lik_y)

```

## Example - Gamma-Hurdle model

**Results**

```{r}

inv_logit = function(x)(exp(x)/(1+exp(x)))
pxl = fm_pixels(mesh, mask = poly)

preds = predict(fit, pxl, ~ data.frame(prob = inv_logit(Intercept_z + space_z),
                                             mean_amount = exp(Intercept_y + space_y)))



preds$prob %>% ggplot() + geom_sf(aes(color = mean)) + ggtitle("Probability of rain")
preds$mean_amount %>% ggplot() + geom_sf(aes(color = mean)) + ggtitle("Mean amount of rain")

```

## Example - Gamma-Hurdle model

We can:

-   use other components in both linear predictors $\eta^1$ and $\eta^2$
-   have shared components between the two linear predictor
-   use other positive-continuous distribution instead of the Gamma (for example log-Normal, Weibull, etc.)

## Example - Poisson- Hurdle model

Let's look again at the fishes examples. We now want to include covariates also in the model for the zero probability:

$$
\begin{eqnarray}
P(Y = 0) = &\pi\\
P(Y=y) = & (1-\pi) \frac{f_Y(y)}{f_Y(0)},& \qquad y =1,2,\dots
\end{eqnarray}
$$ We use the same "trick" as before and we now have $$
\begin{eqnarray}
z\sim\text{Binomial}(\pi,n); &\qquad \eta_1 = \text{logit}(\pi) = \beta^1X\\
z\sim\text{Truncated Poisson}(\lambda); &\qquad \eta_2 =\log(\lambda) =  \beta^2X\\
\end{eqnarray}
$$ In `inlabru` the **truncated Poisson distribution** is called `nzpoisson`

## Example - Poisson- Hurdle model

**Implementation**

1.  Define response for binary and truncated poisson process

```{r}
#| echo: true
zinb  = zinb %>%
  mutate(z = ifelse(count==0,1,0),
         y = ifelse(count==0,NA, count))
```

2.  Define components, observation models and run

```{r}
#| echo: true
cmp = ~ -1 + Intercept_z(1) + Intercept_y(1) +
  nofish_z(nofish, model = "linear") + persons_z(persons, model = "linear") +
    nofish_y(nofish, model = "linear") + persons_y(persons, model = "linear")

lik_z = bru_obs(formula = z~ Intercept_z  + nofish_z + persons_z,
                data = zinb,
                family = "binomial")

lik_y = bru_obs(formula = y~ Intercept_y  + nofish_y + persons_y,
                data = zinb,
                family = "nzpoisson")

fit = bru(cmp, lik_z, lik_y)
```

## Example - Poisson- Hurdle model

**Results**

```{r}
#| echo: true

round(fit$summary.fixed,2)

```

## Example: Binomial-Hurdle model

-   In `inlabru` there is no implementation for the *truncated binomial* (or negative binomial) distribution

-   We can "trick" `inlabru` by using one of the implemented **Type 0** models $$
    y_i|\eta_i  \sim \pi1_{(y=0)} + (1-\pi)\frac{f(y)}{f(0)}
    $$ with a *fixed* and small $\pi$ thus creating a *truncated* distribution!

## Example: Binomial-Hurdle model {.smaller}

**Implementation**

1.  Define response and the components

```{r}
#| echo: true
# Define response for binary and truncated neg. binomial
zinb  = zinb %>% mutate(z = ifelse(count==0,1,0),
                        y = ifelse(count==0,NA, count))
# define model components
cmp = ~ -1 + Intercept_z(1) + Intercept_y(1) + 
  fishing_z(nofish, model = "linear") + fishing_y(nofish, model = "linear") + 
  persons_z(persons, model = "linear") + persons_y(persons, model = "linear") + 
  child_z(child, model = "linear") + child_y(child, model = "linear")
```

. . .

2.  Build the likelihood for the binomial part

```{r}
#| echo: true
# build the observation model
# Poisson model
lik_binom = bru_obs(z ~ Intercept_z + fishing_z + persons_z + child_z ,
                   family = "binomial",
                   data = zinb) 
```

. . .

3.  Define the type 0 Negbinomial with $\pi$ fixed to a small value

```{r}
#| echo: true
#| code-line-numbers: "5-6"

# Negative binomial model
lik_trunc_nbin = bru_obs(y ~ Intercept_y + fishing_y + persons_y + child_y ,
                   family = "zeroinflatednbinomial0",
                   data = zinb,
                   control.family = list(hyper = list(theta = list(initial = -20, 
                                                                   fixed = TRUE))))
```

. . .

4.  Run the model

```{r}
#| echo: true
fit_nbin = bru(cmp, lik_binom, lik_trunc_nbin)
```

## Summary - Treating many zero with `inlabru`

There are mainly two types of models to treat excess of zeros

-   Zero inflated models
-   Hurdle models

## Summary - Treating many zero with `inlabru`

There are mainly two types of models to treat excess of zeros

-   Zero inflated models
    -   Zeros come from two sources
    -   Can only be used for counts (Poisson, Binomial,...)
    -   Four likelihood are implemented in `inlabru` (Type1)
    -   The probability of zero-inflation is **constant**
-   Hurdle models

## Summary - Treating many zero with `inlabru`

There are mainly two types of models to treat excess of zeros

-   Zero inflated models
-   Hurdle models
    -   Only one source of zeros
    -   Positive values can be both discrete and continuous
    -   Two ways to imlement in `inlabru`

## Summary - Treating many zero with `inlabru`

There are mainly two types of models to treat excess of zeros

-   Zero inflated models
-   Hurdle models
    -   Only one source of zeros

    -   Positive values can be both discrete and continuous

    -   Two ways to imlement in `inlabru`

        1.  Use the implemented Type0 likelihoods\

        -   Probability of zero is constant

        2.  Use the "two-likelihood" approach

        -   Probability of zero can be modelled
